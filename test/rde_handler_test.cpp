#include "nlohmann/json.hpp"
#include "rde/external_storer_interface.hpp"
#include "rde/rde_handler.hpp"

#include <memory>
#include <span>

#include <gmock/gmock-matchers.h>
#include <gmock/gmock.h>
#include <gtest/gtest.h>

namespace bios_bmc_smm_error_logger
{
namespace rde
{

using ::testing::Return;

/**
 * @brief Dummy values for annotation dictionary. We do not need the annotation
 * dictionary. So this contains a dictionary with some dummy values. But the RDE
 * header is correct.
 */
constexpr std::array<uint8_t, 38> mRcvDummyAnnotation{
    {0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
     0x0,  0x0,  0xc,  0x0,  0x0,  0xf0, 0xf0, 0xf1, 0x17, 0x1,
     0x0,  0x0,  0x0,  0x0,  0x0,  0x16, 0x0,  0x5,  0x0,  0xc,
     0x84, 0x0,  0x14, 0x0,  0x17, 0x86, 0x94, 0x93}};

constexpr std::array<uint8_t, 38> mRcvDummyInvalidChecksum{
    {0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
     0x0,  0x0,  0xc,  0x0,  0x0,  0xf0, 0xf0, 0xf1, 0x17, 0x1,
     0x0,  0x0,  0x0,  0x0,  0x0,  0x16, 0x0,  0x5,  0x0,  0xc,
     0x84, 0x0,  0x14, 0x0,  0x17, 0x86, 0x00, 0x00}};

/**
 * @brief MultipartReceive command with START_AND_END flag set.
 */
constexpr std::array<uint8_t, 293> mRcvInput0StartAndEnd{
    {0x00, 0x03, 0x02, 0x00, 0x00, 0x00, 0x17, 0x01, 0x00, 0x00, 0x0,  0x0,
     0xc,  0x0,  0x0,  0xf0, 0xf0, 0xf1, 0x17, 0x1,  0x0,  0x0,  0x0,  0x0,
     0x0,  0x16, 0x0,  0x5,  0x0,  0xc,  0x84, 0x0,  0x14, 0x0,  0x0,  0x48,
     0x0,  0x1,  0x0,  0x13, 0x90, 0x0,  0x56, 0x1,  0x0,  0x0,  0x0,  0x0,
     0x0,  0x3,  0xa3, 0x0,  0x74, 0x2,  0x0,  0x0,  0x0,  0x0,  0x0,  0x16,
     0xa6, 0x0,  0x34, 0x3,  0x0,  0x0,  0x0,  0x0,  0x0,  0x16, 0xbc, 0x0,
     0x64, 0x4,  0x0,  0x0,  0x0,  0x0,  0x0,  0x13, 0xd2, 0x0,  0x0,  0x0,
     0x0,  0x52, 0x0,  0x2,  0x0,  0x0,  0x0,  0x0,  0x74, 0x0,  0x0,  0x0,
     0x0,  0x0,  0x0,  0xf,  0xe5, 0x0,  0x46, 0x1,  0x0,  0x66, 0x0,  0x3,
     0x0,  0xb,  0xf4, 0x0,  0x50, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x9,
     0xff, 0x0,  0x50, 0x1,  0x0,  0x0,  0x0,  0x0,  0x0,  0x7,  0x8,  0x1,
     0x50, 0x2,  0x0,  0x0,  0x0,  0x0,  0x0,  0x7,  0xf,  0x1,  0x44, 0x75,
     0x6d, 0x6d, 0x79, 0x53, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x0,  0x43, 0x68,
     0x69, 0x6c, 0x64, 0x41, 0x72, 0x72, 0x61, 0x79, 0x50, 0x72, 0x6f, 0x70,
     0x65, 0x72, 0x74, 0x79, 0x0,  0x49, 0x64, 0x0,  0x53, 0x61, 0x6d, 0x70,
     0x6c, 0x65, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x50, 0x72, 0x6f,
     0x70, 0x65, 0x72, 0x74, 0x79, 0x0,  0x53, 0x61, 0x6d, 0x70, 0x6c, 0x65,
     0x49, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x50, 0x72, 0x6f, 0x70, 0x65,
     0x72, 0x74, 0x79, 0x0,  0x53, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x52, 0x65,
     0x61, 0x6c, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0x0,  0x41,
     0x6e, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61,
     0x6e, 0x0,  0x4c, 0x69, 0x6e, 0x6b, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
     0x0,  0x4c, 0x69, 0x6e, 0x6b, 0x44, 0x6f, 0x77, 0x6e, 0x0,  0x4c, 0x69,
     0x6e, 0x6b, 0x55, 0x70, 0x0,  0x4e, 0x6f, 0x4c, 0x69, 0x6e, 0x6b, 0x0,
     0x0,  0x5e, 0x3f, 0x11, 0x6}};

/**
 * @brief MultipartReceive command with START flag set.
 */
constexpr std::array<uint8_t, 166> mRcvInput1Start{
    {0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x9c, 0x00, 0x00, 0x00, 0x0,  0x0,
     0xc,  0x0,  0x0,  0xf0, 0xf0, 0xf1, 0x17, 0x1,  0x0,  0x0,  0x0,  0x0,
     0x0,  0x16, 0x0,  0x5,  0x0,  0xc,  0x84, 0x0,  0x14, 0x0,  0x0,  0x48,
     0x0,  0x1,  0x0,  0x13, 0x90, 0x0,  0x56, 0x1,  0x0,  0x0,  0x0,  0x0,
     0x0,  0x3,  0xa3, 0x0,  0x74, 0x2,  0x0,  0x0,  0x0,  0x0,  0x0,  0x16,
     0xa6, 0x0,  0x34, 0x3,  0x0,  0x0,  0x0,  0x0,  0x0,  0x16, 0xbc, 0x0,
     0x64, 0x4,  0x0,  0x0,  0x0,  0x0,  0x0,  0x13, 0xd2, 0x0,  0x0,  0x0,
     0x0,  0x52, 0x0,  0x2,  0x0,  0x0,  0x0,  0x0,  0x74, 0x0,  0x0,  0x0,
     0x0,  0x0,  0x0,  0xf,  0xe5, 0x0,  0x46, 0x1,  0x0,  0x66, 0x0,  0x3,
     0x0,  0xb,  0xf4, 0x0,  0x50, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x9,
     0xff, 0x0,  0x50, 0x1,  0x0,  0x0,  0x0,  0x0,  0x0,  0x7,  0x8,  0x1,
     0x50, 0x2,  0x0,  0x0,  0x0,  0x0,  0x0,  0x7,  0xf,  0x1,  0x44, 0x75,
     0x6d, 0x6d, 0x79, 0x53, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x0,  0x43, 0x68,
     0x69, 0x6c, 0x64, 0x41, 0x72, 0x72, 0x61, 0x79, 0x50, 0x72}};

/**
 * @brief MultipartReceive command with END flag set.
 */
constexpr std::array<uint8_t, 137> mRcvInput1End{
    {0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x7b, 0x00, 0x00, 0x00, 0x6f, 0x70,
     0x65, 0x72, 0x74, 0x79, 0x0,  0x49, 0x64, 0x0,  0x53, 0x61, 0x6d, 0x70,
     0x6c, 0x65, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x50, 0x72, 0x6f,
     0x70, 0x65, 0x72, 0x74, 0x79, 0x0,  0x53, 0x61, 0x6d, 0x70, 0x6c, 0x65,
     0x49, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x50, 0x72, 0x6f, 0x70, 0x65,
     0x72, 0x74, 0x79, 0x0,  0x53, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x52, 0x65,
     0x61, 0x6c, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0x0,  0x41,
     0x6e, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61,
     0x6e, 0x0,  0x4c, 0x69, 0x6e, 0x6b, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
     0x0,  0x4c, 0x69, 0x6e, 0x6b, 0x44, 0x6f, 0x77, 0x6e, 0x0,  0x4c, 0x69,
     0x6e, 0x6b, 0x55, 0x70, 0x0,  0x4e, 0x6f, 0x4c, 0x69, 0x6e, 0x6b, 0x0,
     0x0,  0xd1, 0xf3, 0x1e, 0xd0}};

/**
 * @brief MultipartReceive command with START flag set.
 */
constexpr std::array<uint8_t, 106> mRcvInput2Start{
    {0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x60, 0x0,  0x00, 0x00, 0x0,  0x0,
     0xc,  0x0,  0x0,  0xf0, 0xf0, 0xf1, 0x17, 0x1,  0x0,  0x0,  0x0,  0x0,
     0x0,  0x16, 0x0,  0x5,  0x0,  0xc,  0x84, 0x0,  0x14, 0x0,  0x0,  0x48,
     0x0,  0x1,  0x0,  0x13, 0x90, 0x0,  0x56, 0x1,  0x0,  0x0,  0x0,  0x0,
     0x0,  0x3,  0xa3, 0x0,  0x74, 0x2,  0x0,  0x0,  0x0,  0x0,  0x0,  0x16,
     0xa6, 0x0,  0x34, 0x3,  0x0,  0x0,  0x0,  0x0,  0x0,  0x16, 0xbc, 0x0,
     0x64, 0x4,  0x0,  0x0,  0x0,  0x0,  0x0,  0x13, 0xd2, 0x0,  0x0,  0x0,
     0x0,  0x52, 0x0,  0x2,  0x0,  0x0,  0x0,  0x0,  0x74, 0x0,  0x0,  0x0,
     0x0,  0x0,  0x0,  0xf,  0xe5, 0x0,  0x46, 0x1,  0x0,  0x66}};

/**
 * @brief MultipartReceive command with MIDDLE flag set.
 */
constexpr std::array<uint8_t, 106> mRcvInput2Mid{
    {0x00, 0x01, 0x02, 0x00, 0x00, 0x00, 0x60, 0x0,  0x00, 0x00, 0x0,  0x3,
     0x0,  0xb,  0xf4, 0x0,  0x50, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x9,
     0xff, 0x0,  0x50, 0x1,  0x0,  0x0,  0x0,  0x0,  0x0,  0x7,  0x8,  0x1,
     0x50, 0x2,  0x0,  0x0,  0x0,  0x0,  0x0,  0x7,  0xf,  0x1,  0x44, 0x75,
     0x6d, 0x6d, 0x79, 0x53, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x0,  0x43, 0x68,
     0x69, 0x6c, 0x64, 0x41, 0x72, 0x72, 0x61, 0x79, 0x50, 0x72, 0x6f, 0x70,
     0x65, 0x72, 0x74, 0x79, 0x0,  0x49, 0x64, 0x0,  0x53, 0x61, 0x6d, 0x70,
     0x6c, 0x65, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x50, 0x72, 0x6f,
     0x70, 0x65, 0x72, 0x74, 0x79, 0x0,  0x53, 0x61, 0x6d, 0x70}};

/**
 * @brief MultipartReceive command with END flag set.
 */
constexpr std::array<uint8_t, 101> mRcvInput2End{
    {0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x57, 0x0,  0x00, 0x00, 0x6c, 0x65,
     0x49, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x50, 0x72, 0x6f, 0x70, 0x65,
     0x72, 0x74, 0x79, 0x0,  0x53, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x52, 0x65,
     0x61, 0x6c, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0x0,  0x41,
     0x6e, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61,
     0x6e, 0x0,  0x4c, 0x69, 0x6e, 0x6b, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
     0x0,  0x4c, 0x69, 0x6e, 0x6b, 0x44, 0x6f, 0x77, 0x6e, 0x0,  0x4c, 0x69,
     0x6e, 0x6b, 0x55, 0x70, 0x0,  0x4e, 0x6f, 0x4c, 0x69, 0x6e, 0x6b, 0x0,
     0x0,  0xed, 0xcf, 0x21, 0x4b}};

/**
 * @brief RDEOperationInit command with encoded json/dummysimple.json as the
 * payload.
 */
constexpr std::array<uint8_t, 113> mInitOp{
    {0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x60, 0x00, 0x00, 0x00, 0x0,  0xf0, 0xf0, 0xf1, 0x0,  0x0,  0x0,
     0x1,  0x0,  0x0,  0x1,  0x54, 0x1,  0x5,  0x1,  0x2,  0x50, 0x1,  0x9,
     0x44, 0x75, 0x6d, 0x6d, 0x79, 0x20, 0x49, 0x44, 0x0,  0x1,  0x6,  0x20,
     0x1,  0x0,  0x1,  0x8,  0x60, 0x1,  0xb,  0x1,  0x2,  0x38, 0xea, 0x1,
     0x0,  0x2,  0xa3, 0x23, 0x1,  0x0,  0x1,  0x4,  0x70, 0x1,  0x1,  0x0,
     0x1,  0x0,  0x10, 0x1,  0x24, 0x1,  0x2,  0x1,  0x0,  0x0,  0x1,  0xf,
     0x1,  0x2,  0x1,  0x0,  0x70, 0x1,  0x1,  0x1,  0x1,  0x2,  0x40, 0x1,
     0x2,  0x1,  0x2,  0x1,  0x2,  0x0,  0x1,  0x9,  0x1,  0x1,  0x1,  0x2,
     0x40, 0x1,  0x2,  0x1,  0x2}};

class MockExternalStorer : public ExternalStorerInterface
{
  public:
    MOCK_METHOD(bool, publishJson, (std::string_view jsonStr), (override));
};

class RdeHandlerTest : public ::testing::Test
{
  public:
    RdeHandlerTest() : mockExStorer(std::make_unique<MockExternalStorer>())
    {
        mockExStorerPtr = dynamic_cast<MockExternalStorer*>(mockExStorer.get());
        rdeH = std::make_unique<RdeCommandHandler>(std::move(mockExStorer));
    }

  protected:
    std::unique_ptr<ExternalStorerInterface> mockExStorer;
    std::unique_ptr<RdeCommandHandler> rdeH;
    MockExternalStorer* mockExStorerPtr;
    const std::string exJson =
        R"({"Id":"Dummy ID","SampleIntegerProperty":null,"SampleRealProperty":-5576.9123,"SampleEnabledProperty":false,"ChildArrayProperty":[{"AnotherBoolean":true,"LinkStatus":"NoLink"},{"LinkStatus":"NoLink"}]})";
};

TEST_F(RdeHandlerTest, DictionaryStartAndEndTest)
{
    // Send a payload with START_AND_END flag.
    EXPECT_THAT(
        rdeH->decodeRdeCommand(std::span(mRcvInput0StartAndEnd),
                               RdeCommandType::RdeMultiPartReceiveResponse),
        RdeDecodeStatus::RdeStopFlagReceived);
    EXPECT_THAT(rdeH->getDictionaryCount(), 1);
    // Send annotation dictionary.
    EXPECT_THAT(
        rdeH->decodeRdeCommand(std::span(mRcvDummyAnnotation),
                               RdeCommandType::RdeMultiPartReceiveResponse),
        RdeDecodeStatus::RdeStopFlagReceived);
    EXPECT_THAT(rdeH->getDictionaryCount(), 2);

    // Send the encoded payload.
    EXPECT_CALL(*mockExStorerPtr, publishJson(exJson)).WillOnce(Return(true));
    EXPECT_THAT(rdeH->decodeRdeCommand(std::span(mInitOp),
                                       RdeCommandType::RdeOperationInitRequest),
                RdeDecodeStatus::RdeNoError);
}

TEST_F(RdeHandlerTest, DictionaryStartThenEndTest)
{
    // Send a payload with START flag.
    EXPECT_THAT(
        rdeH->decodeRdeCommand(std::span(mRcvInput1Start),
                               RdeCommandType::RdeMultiPartReceiveResponse),
        RdeDecodeStatus::RdeNoError);
    // We didn't send END. So dictionary count should be 0.
    EXPECT_THAT(rdeH->getDictionaryCount(), 0);
    // Send a payload with END flag.
    EXPECT_THAT(
        rdeH->decodeRdeCommand(std::span(mRcvInput1End),
                               RdeCommandType::RdeMultiPartReceiveResponse),
        RdeDecodeStatus::RdeStopFlagReceived);
    EXPECT_THAT(rdeH->getDictionaryCount(), 1);
    // Send annotation dictionary.
    EXPECT_THAT(
        rdeH->decodeRdeCommand(std::span(mRcvDummyAnnotation),
                               RdeCommandType::RdeMultiPartReceiveResponse),
        RdeDecodeStatus::RdeStopFlagReceived);
    EXPECT_THAT(rdeH->getDictionaryCount(), 2);

    // Send the encoded payload.
    EXPECT_CALL(*mockExStorerPtr, publishJson(exJson)).WillOnce(Return(true));
    EXPECT_THAT(rdeH->decodeRdeCommand(std::span(mInitOp),
                                       RdeCommandType::RdeOperationInitRequest),
                RdeDecodeStatus::RdeNoError);

    // Sending the START again for same resource ID should decrease the
    // dictionary count.
    EXPECT_THAT(
        rdeH->decodeRdeCommand(std::span(mRcvInput1Start),
                               RdeCommandType::RdeMultiPartReceiveResponse),
        RdeDecodeStatus::RdeNoError);
    EXPECT_THAT(rdeH->getDictionaryCount(), 1);
}

TEST_F(RdeHandlerTest, DictionaryStartMidEndTest)
{
    // Send a payload with START flag.
    EXPECT_THAT(
        rdeH->decodeRdeCommand(std::span(mRcvInput2Start),
                               RdeCommandType::RdeMultiPartReceiveResponse),
        RdeDecodeStatus::RdeNoError);
    // We didn't send END. So dictionary count should be 0.
    EXPECT_THAT(rdeH->getDictionaryCount(), 0);
    // Send a payload with MIDDLE flag.
    EXPECT_THAT(
        rdeH->decodeRdeCommand(std::span(mRcvInput2Mid),
                               RdeCommandType::RdeMultiPartReceiveResponse),
        RdeDecodeStatus::RdeNoError);
    // We didn't send END. So dictionary count should be 0.
    EXPECT_THAT(rdeH->getDictionaryCount(), 0);
    // Send a payload with END flag.
    EXPECT_THAT(
        rdeH->decodeRdeCommand(std::span(mRcvInput2End),
                               RdeCommandType::RdeMultiPartReceiveResponse),
        RdeDecodeStatus::RdeStopFlagReceived);
    EXPECT_THAT(rdeH->getDictionaryCount(), 1);

    // Send annotation dictionary.
    EXPECT_THAT(
        rdeH->decodeRdeCommand(std::span(mRcvDummyAnnotation),
                               RdeCommandType::RdeMultiPartReceiveResponse),
        RdeDecodeStatus::RdeStopFlagReceived);
    EXPECT_THAT(rdeH->getDictionaryCount(), 2);

    // Send the encoded payload.
    EXPECT_CALL(*mockExStorerPtr, publishJson(exJson)).WillOnce(Return(true));
    EXPECT_THAT(rdeH->decodeRdeCommand(std::span(mInitOp),
                                       RdeCommandType::RdeOperationInitRequest),
                RdeDecodeStatus::RdeNoError);
}

TEST_F(RdeHandlerTest, InvalidDictionaryFlowTest)
{
    // Send a payload with MIDDLE flag before START and it should fail.
    EXPECT_THAT(
        rdeH->decodeRdeCommand(std::span(mRcvInput2Mid),
                               RdeCommandType::RdeMultiPartReceiveResponse),
        RdeDecodeStatus::RdeInvalidPktOrder);
    // Send a payload with END flag before START and it should fail.
    EXPECT_THAT(
        rdeH->decodeRdeCommand(std::span(mRcvInput2End),
                               RdeCommandType::RdeMultiPartReceiveResponse),
        RdeDecodeStatus::RdeInvalidPktOrder);
}

TEST_F(RdeHandlerTest, MissingDictionaryTest)
{
    // Try decoding without any dictionaries.
    EXPECT_THAT(rdeH->decodeRdeCommand(std::span(mInitOp),
                                       RdeCommandType::RdeOperationInitRequest),
                RdeDecodeStatus::RdeNoDictionary);

    // Try decoding just with annotation dictionary.
    EXPECT_THAT(
        rdeH->decodeRdeCommand(std::span(mRcvDummyAnnotation),
                               RdeCommandType::RdeMultiPartReceiveResponse),
        RdeDecodeStatus::RdeStopFlagReceived);
    EXPECT_THAT(rdeH->decodeRdeCommand(std::span(mInitOp),
                                       RdeCommandType::RdeOperationInitRequest),
                RdeDecodeStatus::RdeNoDictionary);
}

TEST_F(RdeHandlerTest, InvalidDictionaryChecksumTest)
{
    // Send a dictionary with an invalid checksum.
    EXPECT_THAT(
        rdeH->decodeRdeCommand(std::span(mRcvDummyInvalidChecksum),
                               RdeCommandType::RdeMultiPartReceiveResponse),
        RdeDecodeStatus::RdeInvalidChecksum);
}

} // namespace rde
} // namespace bios_bmc_smm_error_logger
