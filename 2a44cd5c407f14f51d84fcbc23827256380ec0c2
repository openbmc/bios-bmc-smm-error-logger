{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "8c9a809b_d6d2ca1e",
        "filename": "src/buffer.cpp",
        "patchSetId": 7
      },
      "lineNbr": 263,
      "author": {
        "id": 1000388
      },
      "writtenOn": "2022-06-17T14:25:48Z",
      "side": 1,
      "message": "I\u0027m a dummy and this is wrong I\u0027m pretty sure - will fix and cover it with the corner case",
      "range": {
        "startLine": 260,
        "startChar": 0,
        "endLine": 263,
        "endChar": 74
      },
      "revId": "2a44cd5c407f14f51d84fcbc23827256380ec0c2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "20f03976_e52b135f",
        "filename": "src/buffer.cpp",
        "patchSetId": 7
      },
      "lineNbr": 263,
      "author": {
        "id": 1000885
      },
      "writtenOn": "2022-06-17T15:14:57Z",
      "side": 1,
      "message": "what\u0027s the relationship between WritePtr and ReadPtr.\n\nWhy do you need to read if the WritePtr is greater than the ReadPtr or maybe the other way around is wrong.\n\nIf ReadPrt \u003e WritePrt.\n\nWouldn\u0027t\n```\n    while (byteRead \u003c bytesToRead)\n    {\n        EntryPair entryPair \u003d readEntry(currentReadPtr);\n        byteRead +\u003d sizeof(struct QueueEntryHeader) + entryPair.second.size();\n        entryPairs.push_back(entryPair);\n\n        // Note: readEntry() will update cachedBufferHeader.bmcReadPtr\n        currentReadPtr \u003d\n            boost::endian::little_to_native(cachedBufferHeader.bmcReadPtr);\n    }\n```\n\nset ReadPrt to be even greater?",
      "parentUuid": "8c9a809b_d6d2ca1e",
      "range": {
        "startLine": 260,
        "startChar": 0,
        "endLine": 263,
        "endChar": 74
      },
      "revId": "2a44cd5c407f14f51d84fcbc23827256380ec0c2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5b9193c8_9059036f",
        "filename": "src/buffer.cpp",
        "patchSetId": 7
      },
      "lineNbr": 263,
      "author": {
        "id": 1000388
      },
      "writtenOn": "2022-06-17T15:29:20Z",
      "side": 1,
      "message": "This should be the right snippet:\n\n```\n    if (currentBiosWritePtr \u003e currentReadPtr)\n    {\n        // If WritePtr is bigger than ReadPtr, simply subtract\n        bytesToRead \u003d currentBiosWritePtr - currentReadPtr;\n    }\n    else\n    {\n        // If ReadPtr is bigger than WritePtr, calculate the bytes the \"end\"\n        // (QueueSize - ReadPtr) + bytes to read from the \"beginning\" (0 +\n        // WritePtr) offset by 1 (to acommodate the size to offset conversion)\n        bytesToRead \u003d (queueSize - currentReadPtr) + currentBiosWritePtr + 1;\n    }\n```\n\nFor the logic I was going for. As to it working - TBD",
      "parentUuid": "20f03976_e52b135f",
      "range": {
        "startLine": 260,
        "startChar": 0,
        "endLine": 263,
        "endChar": 74
      },
      "revId": "2a44cd5c407f14f51d84fcbc23827256380ec0c2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6348d039_46d64b64",
        "filename": "src/buffer.cpp",
        "patchSetId": 7
      },
      "lineNbr": 263,
      "author": {
        "id": 1000885
      },
      "writtenOn": "2022-06-17T15:49:32Z",
      "side": 1,
      "message": "wouldn\u0027t that read even more data?\n\n(queueSize - currentReadPtr) \u003e 0 \n\nso\n\n(queueSize - currentReadPtr) + currentBiosWritePtr + 1 \u003e currentReadPtr - currentBiosWritePtr\n\nI guess that\u0027s only true if\n\nqueueSize + 1 \u003e 2 *(currentReadPtr - currentBiosWritePtr)\n\n\n----\n\nI guess the first question is that where are we support to read to at the end of the day. What is currentReadPtr suppose to be at the end. I think I missed that.",
      "parentUuid": "5b9193c8_9059036f",
      "range": {
        "startLine": 260,
        "startChar": 0,
        "endLine": 263,
        "endChar": 74
      },
      "revId": "2a44cd5c407f14f51d84fcbc23827256380ec0c2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "41d99488_4e16eeae",
        "filename": "src/buffer.cpp",
        "patchSetId": 7
      },
      "lineNbr": 263,
      "author": {
        "id": 1000388
      },
      "writtenOn": "2022-06-17T16:24:38Z",
      "side": 1,
      "message": "Oh I see, currentReadPtr is updated as part of wraparoundRead() and should be the currentReadPtr + number of bytes read.\n\nImagine the simple case of readPtr and writePtr starts at 0 then writePtr is incremented by 1 (as 1 byte is written), we expect readPtr to read 1 byte and increment to 1 (it\u0027s supposed to be \"ahead\" by 1).\n\nTake the more complex case of 10 byte queue {0, ... , 9}. The readPtr is at 9 and writePtr is at 0, which means we \"SHOULD\" read by 1 byte.\n\n`bytesToRead \u003d (queueSize - currentReadPtr) + currentBiosWritePtr + 1;`\n\nbytesToRead \u003d (10 - 9) + 0 + 1 \u003d 2 (Oops, it looks like my proposed solution had an off by 1 bug, taking out the +1 gets us the 1)",
      "parentUuid": "6348d039_46d64b64",
      "range": {
        "startLine": 260,
        "startChar": 0,
        "endLine": 263,
        "endChar": 74
      },
      "revId": "2a44cd5c407f14f51d84fcbc23827256380ec0c2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "45ba524c_c66bcb22",
        "filename": "src/buffer.cpp",
        "patchSetId": 7
      },
      "lineNbr": 263,
      "author": {
        "id": 1000885
      },
      "writtenOn": "2022-06-17T16:33:20Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "41d99488_4e16eeae",
      "range": {
        "startLine": 260,
        "startChar": 0,
        "endLine": 263,
        "endChar": 74
      },
      "revId": "2a44cd5c407f14f51d84fcbc23827256380ec0c2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}