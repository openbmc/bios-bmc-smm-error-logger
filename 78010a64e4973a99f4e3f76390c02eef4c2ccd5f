{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "ebc96db4_69bfe303",
        "filename": "src/buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 58,
      "author": {
        "id": 1000885
      },
      "writtenOn": "2022-06-08T07:32:03Z",
      "side": 1,
      "message": "rm std::",
      "range": {
        "startLine": 58,
        "startChar": 16,
        "endLine": 58,
        "endChar": 21
      },
      "revId": "78010a64e4973a99f4e3f76390c02eef4c2ccd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "74491084_bc289cc3",
        "filename": "src/buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 58,
      "author": {
        "id": 1000388
      },
      "writtenOn": "2022-06-09T00:42:09Z",
      "side": 1,
      "message": "Good catch, remnant of my old local code that I\u0027m copying from",
      "parentUuid": "ebc96db4_69bfe303",
      "range": {
        "startLine": 58,
        "startChar": 16,
        "endLine": 58,
        "endChar": 21
      },
      "revId": "78010a64e4973a99f4e3f76390c02eef4c2ccd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c4446347_98d8206c",
        "filename": "src/buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 58,
      "author": {
        "id": 1001322
      },
      "writtenOn": "2022-06-09T06:22:21Z",
      "side": 1,
      "message": "If I may ask, what is wrong in using std:: ?",
      "parentUuid": "74491084_bc289cc3",
      "range": {
        "startLine": 58,
        "startChar": 16,
        "endLine": 58,
        "endChar": 21
      },
      "revId": "78010a64e4973a99f4e3f76390c02eef4c2ccd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "46e8760b_f384567b",
        "filename": "src/buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 58,
      "author": {
        "id": 1000388
      },
      "writtenOn": "2022-06-09T17:06:04Z",
      "side": 1,
      "message": "it is not technically wrong, but in an earlier patch, we agreed that having std:: everywhere was not good for readability (as it was becoming verbose)",
      "parentUuid": "c4446347_98d8206c",
      "range": {
        "startLine": 58,
        "startChar": 16,
        "endLine": 58,
        "endChar": 21
      },
      "revId": "78010a64e4973a99f4e3f76390c02eef4c2ccd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ec4d722e_5a6da656",
        "filename": "src/buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 63,
      "author": {
        "id": 1000885
      },
      "writtenOn": "2022-06-08T07:32:03Z",
      "side": 1,
      "message": "add the expected read size",
      "range": {
        "startLine": 63,
        "startChar": 23,
        "endLine": 63,
        "endChar": 80
      },
      "revId": "78010a64e4973a99f4e3f76390c02eef4c2ccd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2b4c9e6c_77e59121",
        "filename": "src/buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 63,
      "author": {
        "id": 1000388
      },
      "writtenOn": "2022-06-09T00:42:09Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "ec4d722e_5a6da656",
      "range": {
        "startLine": 63,
        "startChar": 23,
        "endLine": 63,
        "endChar": 80
      },
      "revId": "78010a64e4973a99f4e3f76390c02eef4c2ccd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ade4d5f0_68d8a092",
        "filename": "src/buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 68,
      "author": {
        "id": 1000885
      },
      "writtenOn": "2022-06-08T07:32:03Z",
      "side": 1,
      "message": "maybe\n```\nstruct CircularBufferHeader *bufferHeader \u003d reinterpret_cast\u003cCircularBufferHeader *\u003e(bytesRead.data());\n\ncachedBufferHeader \u003d *bufferHeader;\n```\nwill work.\n\nI think this avoid one copy.",
      "range": {
        "startLine": 67,
        "startChar": 0,
        "endLine": 68,
        "endChar": 61
      },
      "revId": "78010a64e4973a99f4e3f76390c02eef4c2ccd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "843692dc_a9b831b2",
        "filename": "src/buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 68,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-06-08T15:16:19Z",
      "side": 1,
      "message": "Just memcpying the data in has endian issues that you should account for.\n\nAlso, memcpy is generally banned within the project.  use memcpy_s instead (which takes two sizes, and should remove the need for the size variable as well).",
      "range": {
        "startLine": 68,
        "startChar": 46,
        "endLine": 68,
        "endChar": 47
      },
      "revId": "78010a64e4973a99f4e3f76390c02eef4c2ccd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "03fbc848_39ea72bb",
        "filename": "src/buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 68,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-06-08T15:21:24Z",
      "side": 1,
      "message": "FYI for learning, list of banned functions and alternatives.\n\nhttps://github.com/intel/safestringlib/wiki/SDL-List-of-Banned-Functions",
      "parentUuid": "843692dc_a9b831b2",
      "range": {
        "startLine": 68,
        "startChar": 46,
        "endLine": 68,
        "endChar": 47
      },
      "revId": "78010a64e4973a99f4e3f76390c02eef4c2ccd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bcd5e91c_61f03014",
        "filename": "src/buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 68,
      "author": {
        "id": 1000388
      },
      "writtenOn": "2022-06-09T00:42:09Z",
      "side": 1,
      "message": "Thanks, that\u0027s much cleaner and a pattern I meant to do (and forgot the last step).",
      "parentUuid": "ade4d5f0_68d8a092",
      "range": {
        "startLine": 67,
        "startChar": 0,
        "endLine": 68,
        "endChar": 61
      },
      "revId": "78010a64e4973a99f4e3f76390c02eef4c2ccd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "50f95617_68a0391a",
        "filename": "src/buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 68,
      "author": {
        "id": 1000388
      },
      "writtenOn": "2022-06-09T00:42:09Z",
      "side": 1,
      "message": "Ah, I thought memcpy was not so safe (as I learned in college) but I saw it being used elsewhere and thought it was ok on the newer C++ (I definitely learned C++99 when I was in school). Good to know that the _s variant of functions are still the safer version of these functions, thanks!.\n\nGood point on the endianness, I think what Willy proposed may work better for us here.",
      "parentUuid": "03fbc848_39ea72bb",
      "range": {
        "startLine": 68,
        "startChar": 46,
        "endLine": 68,
        "endChar": 47
      },
      "revId": "78010a64e4973a99f4e3f76390c02eef4c2ccd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "30ce65e5_deac6879",
        "filename": "src/buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 68,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-06-09T00:52:16Z",
      "side": 1,
      "message": "what willy suggested has the same issues.  Casting to a struct doesn\u0027t fix endianness issues, and because it seems likely that we might have to share this struct between non biendian things (I\u0027m not sure what smm is) it seems important to handle this.\n\n\nTechnically memcpy_s is no more \"safe\" than memcpy, it\u0027s just easier to use properly and wraps up the range checks a little more helpfully.  Also, FWIW, you can actually get rid of the size check, as memcpy_s will now do that for you.",
      "parentUuid": "50f95617_68a0391a",
      "range": {
        "startLine": 68,
        "startChar": 46,
        "endLine": 68,
        "endChar": 47
      },
      "revId": "78010a64e4973a99f4e3f76390c02eef4c2ccd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a1b02a18_7f16fb55",
        "filename": "src/buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 68,
      "author": {
        "id": 1000388
      },
      "writtenOn": "2022-06-09T01:22:43Z",
      "side": 1,
      "message": "Good point on endianness - is there a common OpenBMC practice? Or would using something like boost endian library to set each of the multi-byte variables in this struct as a set endian be enough?",
      "parentUuid": "30ce65e5_deac6879",
      "range": {
        "startLine": 68,
        "startChar": 46,
        "endLine": 68,
        "endChar": 47
      },
      "revId": "78010a64e4973a99f4e3f76390c02eef4c2ccd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "90c7c6c3_70ed3168",
        "filename": "src/buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 68,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-06-09T18:14:20Z",
      "side": 1,
      "message": "FWIW, I generally tend to just do the braindead thing, and construct a new struct manually.\n\nint32_t myInt \u003d bytes[0] \u003c\u003c 24 + bytes[1] \u003c\u003c 16 + bytes[2] \u003c\u003c 8 + bytes[3];\n\nSo it\u0027s brutally obvious what the intended endianness is to someone reading it, and your in-process data structures aren\u0027t tied directly to the data structures that are being sent over the wire.  This works fine so long as you\u0027re not doing anything super performance sensitive (in practice the optimizer is pretty good about recognizing patterns like this for most architectures).\n\nFWIW, there are other approaches that involve doing the cast like willy suggests, then relying on the ntoh class of methods to convert any integers from network to native.\nhttps://linux.die.net/man/3/ntohl\n\nIf you\u0027re in a project that uses boost, boost endian wraps those functions in some \"endian safe\" numeric primitives (for example big_int32_buf_t) that make it brutally obvious to the reader what the encoding is, and makes them very hard to do wrong, as they overload all the numeric operators to convert the endianness on the way back out.\n\nAs with anything, lots of ways to solve it, do what makes sense to your sensibilities.",
      "parentUuid": "a1b02a18_7f16fb55",
      "range": {
        "startLine": 68,
        "startChar": 46,
        "endLine": 68,
        "endChar": 47
      },
      "revId": "78010a64e4973a99f4e3f76390c02eef4c2ccd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "502bdcd3_6dc83008",
        "filename": "src/buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 68,
      "author": {
        "id": 1000388
      },
      "writtenOn": "2022-06-14T03:53:32Z",
      "side": 1,
      "message": "Apologies for getting to this review late. Thanks for the detailed answer - I\u0027m actually not too familiar with the boost endian library and its magic so I\u0027m not 100% sure, but would declaring the variables in the struct with the boost endian library and reinterpret_casting / memcpying be enough? Otherwise, the manual struct construction seems... pretty tedious with how many members this struct has.\n\nI did notice that William (wak@) has created and used stdplus::raw::copyFrom for structs with endianness (in our internal repo) although I wasn\u0027t 100% sure how as it seems to be a memcpy at its core: https://github.com/openbmc/stdplus/blob/master/src/stdplus/raw.hpp#L64-L83\n\nI\u0027ll update this patch assuming this stdplus::raw::copyFrom + boost:endian is magical.",
      "parentUuid": "90c7c6c3_70ed3168",
      "range": {
        "startLine": 68,
        "startChar": 46,
        "endLine": 68,
        "endChar": 47
      },
      "revId": "78010a64e4973a99f4e3f76390c02eef4c2ccd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3bf21b59_cd6e15f6",
        "filename": "src/buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 68,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-06-14T15:19:59Z",
      "side": 1,
      "message": "\u003e but would declaring the variables in the struct with the boost endian library and reinterpret_casting / memcpying be enough?\n\nyes.  In this case, i don\u0027t think you need copyFrom.  If you use it, you need to catch and handle the exception it throws.",
      "parentUuid": "502bdcd3_6dc83008",
      "range": {
        "startLine": 68,
        "startChar": 46,
        "endLine": 68,
        "endChar": 47
      },
      "revId": "78010a64e4973a99f4e3f76390c02eef4c2ccd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6d75fe86_0ff134ea",
        "filename": "src/buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 68,
      "author": {
        "id": 1000388
      },
      "writtenOn": "2022-06-14T15:38:06Z",
      "side": 1,
      "message": "Good point, thanks",
      "parentUuid": "3bf21b59_cd6e15f6",
      "range": {
        "startLine": 68,
        "startChar": 46,
        "endLine": 68,
        "endChar": 47
      },
      "revId": "78010a64e4973a99f4e3f76390c02eef4c2ccd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}